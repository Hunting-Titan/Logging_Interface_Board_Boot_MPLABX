/**************************************************************************************/
/** \file test.c
  
  Company:
    Hunting Titan
  
  File Name:
    test.c

  Summary:
    This file contains the source code for the CLASS B system tests to verify
    controller health before the main system tasks begin.  The majority of this code is
    taken from the CLASS B demo code.

  Description:
    This file contains the source code for the CLASS B system tests to verify
    controller health before the main system tasks begin.  It 
    implements the logic of the application's state machine and it may call 
    API routines of other MPLAB Harmony modules in the system, such as drivers,
    system services, and middleware.  However, it does not call any of the
    system interfaces (such as the "Initialize" and "Tasks" functions) of any of
    the modules in the system or make any assumptions about when those functions
    are called.  
 **************************************************************************************/

/**************************************************************************************/
/**************************************************************************************/
/*  Section: Included Files                                                           */                                                      
/**************************************************************************************/
/**************************************************************************************/

#include "test.h"

/**************************************************************************************/
/**************************************************************************************/
/* Section: Structure Data and Local Variables                                        */
/**************************************************************************************/
/**************************************************************************************/
/* Structure Data

  Summary:
    These structures hold required data.

  Description:
    These structures hold required data. These are here to link these 
    structures for use by the local functions.
  Remarks:
    These structures should be initialized by the APP_Initialize function.
    
    These are defined in test.h
*/

ClassB_Test_Flags TEST_FLAG;



/***************************************************************************************
  Class B Library Implementation Test Function

  Summary:
    This function contains the test program for the 
    the Class B Safety Software Library on PIC32MX MCUs.
    
***************************************************************************************/

/*#define     SYSTEM_CLOCK        SYS_CLK_FREQ*/

CLASSBRESULT ClassB_Test(void)
{
    TEST_FLAG.returnCode = CLASSB_TEST_FAIL;                                            /* Initialize the test flags to fail status.*/    
    TEST_FLAG.checkerboardRam_TestResult = CLASSB_TEST_FAIL;
    TEST_FLAG.cpuRegister_TestResult=CLASSB_TEST_FAIL;
    TEST_FLAG.programCounter_TestResult=CLASSB_TEST_FAIL;
    TEST_FLAG.checkerboardRam_TestResult=CLASSB_TEST_FAIL;
    TEST_FLAG.marchCRam_TestResult=CLASSB_TEST_FAIL;
    TEST_FLAG.marchCRamStack_TestResult=CLASSB_TEST_FAIL;
    TEST_FLAG.marchBRam_TestResult=CLASSB_TEST_FAIL;
    TEST_FLAG.flash_TestResult=CLASSB_TEST_FAIL;


    /***********************************************************************************
                                    CPU REGISTER TEST                                                           
    ***********************************************************************************/

    TEST_FLAG.cpuRegister_TestResult = CLASSB_CPURegistersTest();

    /***********************************************************************************
                                    PROGRAM COUNTER TEST                          
        This requires a special linker script (elf32pic32mx.ld) to be added           
        as part of the project. See the description in SSL_PcTest.h                  
    ***********************************************************************************/

    TEST_FLAG.programCounter_TestResult = CLASSB_CPUPCTest();

    /***********************************************************************************
                                    RAM TESTS                                                                   
    ***********************************************************************************/
                                                                                        /* Variables used for RAM Tests.*/
/* This code generated by Microchip and is implementation specific.*/
/*LDRA_INSPECTED 127 S*/
/*LDRA_INSPECTED 219 S*/
    extern uint32_t  _stack[];                                                          /* The address of the stack, as placed by the linker.*/
/* This code generated by Microchip and is implementation specific.*/
/*LDRA_INSPECTED 127 S*/
/*LDRA_INSPECTED 219 S*/
    extern uint32_t  _min_stack_size[];                                                 /* The size of the stack, as defined in the project.*/
/* This code generated by Microchip and is implementation specific.*/
/*LDRA_INSPECTED 127 S*/
/*LDRA_INSPECTED 219 S*/    
    extern char _sdata_begin[];                                                         /* The address of the data segment, as placed by the linker.*/

    uint32_t     *ramTestStartAddress;                                                  /* Starting address for the test.*/ 
    uint32_t     ramTestSize;                                                           /* The size of the tested area, bytes.*/
    uint32_t     stackTestSize;                                                         /* The size of the tested area, bytes.*/
    
    /***********************************************************************************
                                    Checker Board RAM test
         
        We'll test 1KB chunk at the middle of the RAM
        Note that this test is not destructive
        The size of the RAM area to test has to be multiple of 64.
        It has to NOT overlap the stack space!
    ***********************************************************************************/
    uint32_t        ramTotSize;                                                         /* Total RAM available, without stack.*/
    uint32_t*       ramStartAddress;                                                    /* Starting RAM address for the test.*/
    uint32_t*       ramEndAddress;                                                      /* end address of RAM.*/

    uint32_t        stackTotSize;                                                       /* total RAM available, without stack.*/
    uint32_t*       stackStartAddress;                                                  /* starting RAM address for the test.*/
    uint32_t*       stackEndAddress;                                                    /* end address of RAM.*/

    /***********************************************************************************
        The stack is filled from the high memory to the lower memory.  So, the 
        sp will begin at stackStartAddress.  And, stackStartAddress will be a 
        larger value than stackEndAddress.
    ***********************************************************************************/
/* This code generated by Microchip and is implementation specific.*/
/*LDRA_INSPECTED 94 S*/
/*LDRA_INSPECTED 95 S*/
    stackStartAddress= (uint32_t*)_stack;
/* This code generated by Microchip and is implementation specific.*/
/* No issues with pointer math and cast use here.*/
/*LDRA_INSPECTED 87 S*/
/*LDRA_INSPECTED 439 S*/
/*LDRA_INSPECTED 439 S*/
    stackEndAddress= (uint32_t*)(_stack-((uint32_t)_min_stack_size));
/* This code generated by Microchip and is implementation specific.*/
/* No issues with pointer math and cast use here.*/
/*LDRA_INSPECTED 87 S*/
/*LDRA_INSPECTED 439 S*/
/*LDRA_INSPECTED 439 S*/
/*LDRA_INSPECTED 438 S*/    
    stackTotSize=(uint32_t)stackStartAddress - (uint32_t)stackEndAddress;
    
                                                                                        /* The available memory is from the start of RAM to the end of the stack.*/
/* This code generated by Microchip and is implementation specific.*/
/*LDRA_INSPECTED 94 S*/ 
/*LDRA_INSPECTED 95 S*/ 
    ramStartAddress= (uint32_t*)_sdata_begin;
    ramEndAddress= stackEndAddress;
/* This code generated by Microchip and is implementation specific.*/
/* No issues with pointer math and cast use here.*/
/*LDRA_INSPECTED 87 S*/
/*LDRA_INSPECTED 439 S*/
    ramTotSize=(uint32_t)ramEndAddress - (uint32_t)ramStartAddress;
    
    /***********************************************************************************
        FOR THE RAM
        Choose either 1k or the total size to test whichever is smaller.
        Find a spot of that size in the middle of the test area.
    ***********************************************************************************/
    ramTestSize = (ramTotSize>0x400U)?0x400U:ramTotSize;
    ramTestSize&=0xffffffc0U;
/* This code generated by Microchip and is implementation specific.*/
/* No issues with pointer math and cast use here.*/
/*LDRA_INSPECTED 87 S*/
/*LDRA_INSPECTED 439 S*/
    ramTestStartAddress =
        (uint32_t *)(ramStartAddress+(((ramTotSize-ramTestSize)/2U)/sizeof(uint32_t)));
    
    /***********************************************************************************
        FOR THE STACK
        Choose either 1k or the total size to test whichever is smaller.
        Find a spot of that size in the middle of the test area.
        The ram test area is used to save the stack, so its size has to be larger.
    ***********************************************************************************/
    stackTestSize = (stackTotSize>0x400U)?0x400U:stackTotSize;
    stackTestSize = 
            (ramTestSize>stackTestSize)?stackTestSize:(ramTestSize-sizeof(uint32_t));
    stackTestSize&=0xffffffc0U;
 
    TEST_FLAG.checkerboardRam_TestResult =                                               /* Test it.*/
            CLASSB_RAMCheckerBoardTest(ramTestStartAddress, ramTestSize);

    /***********************************************************************************
                                 March B Ram Test      
    
        We'll test it using the March B test.
        Note that the size of the RAM to test has to be multiple of 4.
    ***********************************************************************************/
    TEST_FLAG.marchBRam_TestResult = 
            CLASSB_RAMMarchBTest(ramTestStartAddress, ramTestSize );

    /***********************************************************************************
                                MarchC RAM tests    
    
        We'll test it using the March C test.
        Note that the size of the RAM to test has to be a multiple of 4.
    ***********************************************************************************/
    TEST_FLAG.marchCRam_TestResult = 
            CLASSB_RAMMarchCTest(ramTestStartAddress, ramTestSize );

    /***********************************************************************************
                                MarchC RAM and Stack Test
    
        We want to make sure that both the RAM and the stack space are okay.       
        We'll test it using the March C and Stack tests before we use it.
        Note that the size of the RAM to test has to be multiple of 4.
        Also, the size of the tested RAM area has to be greater than the
        size of the tested stack area. 
        This test is destructive for the RAM area but preserves the Stack area.
    ***********************************************************************************/
    TEST_FLAG.marchCRamStack_TestResult = 
            CLASSB_RAMMarchCStackTest(ramTestStartAddress, ramTestSize);
    {
        /*******************************************************************************
                                    FLASH CRC TEST                                                          
        
            This function can be called at startup to generate the Reference checksum.
            The same function can be called periodically and the generated checksum  
            can be compared with the reference checksum.
            If both are the same the "flash_TestResult" status bit can be set.
        *******************************************************************************/ 

        uint32_t flashCrcRef, flashCrc;                                                 /* Reference and current CRC values.*/
        uint32_t crcSeed=0xffff;                                                        /* Initial CRC register value.*/
                                                                                        /* This is the recommended CRC seed*/
                                                                                        /* for checking properly long 0 streams.*/

                                                                                        /* Calculate the CRC16 of the whole program flash (K0).*/
/* This code generated by Microchip and is implementation specific.*/
/*LDRA_INSPECTED 440 S*/ 
        char* flashStartAddress = (char*)0x9d000000U;                                   /* Fixed start K0 address on PIC32MX devices.*/
/* This code generated by Microchip and is implementation specific.*/
/* No issues with pointer math and cast use here.*/
/*LDRA_INSPECTED 87 S*/
/*LDRA_INSPECTED 439 S*/
/*LDRA_INSPECTED 567 S*/
        char* flashEndAddress =  flashStartAddress+0x1000;                              /* Size of the flash on this device*/
                                                                                        /* the BMX register stores the Flash size for this part.*/

                                                                                        /* First we calculate the reference Flash CRC value.*/
        flashCrcRef = CLASSB_CRCFlashTest( flashStartAddress, 
                flashEndAddress, CRC_16_GEN_POLY, crcSeed);
        
        flashCrc = CLASSB_CRCFlashTest( flashStartAddress,                              /* At some time later we calculate again the CRC of the Flash.*/ 
                flashEndAddress, CRC_16_GEN_POLY, crcSeed);
        
        if ( flashCrc==flashCrcRef)                                                     /* Make sure that the periodic check is equal to the reference one.*/
        {
            TEST_FLAG.flash_TestResult=CLASSB_TEST_PASS;                                /* We are confident that the data programmed in Flash*/
                                                                                        /* has not been altered in any way.*/             
        }
        else
        { 
            TEST_FLAG.flash_TestResult=CLASSB_TEST_FAIL;
        }
    }
    /***********************************************************************************
                    CLOCK  TEST WITH SECONDARY OSCILLATOR AS REFERENCE CLOCK                
        This test requires that a standard 32.768 KHz crystal is connected        
        at the SOSC input.  We'll count for 1 second and check the system clock 
        to be within +/- 40%.                                      
    
        This test is not performed for now.     
    ***********************************************************************************/
    /*testFlag.clock_TestResult=
            CLASSB_ClockTest(SYSTEM_CLOCK, CLOCK_TEST_REFERENCE_FREQ, 1, 40)*/

    /***********************************************************************************
                    CLOCK TEST WITH 50Hz LINE FREQUENCY AS REFERENCE CLOCK                    
        This test requires an 50 Hz external reference frequency to be fed        
        to the IC1 input pin and check the system clock to be within +/- 40%.                                         
    
        This test is not performed for now.
    ***********************************************************************************/
    /*testFlag.clockLine_TestResult=CLASSB_ClockLineFreqTest(SYSTEM_CLOCK, 50, 40)*/

        
    if((TEST_FLAG.checkerboardRam_TestResult == CLASSB_TEST_PASS) &&                    /* Make sure all of the tests passed.*/
    (TEST_FLAG.cpuRegister_TestResult == CLASSB_TEST_PASS) &&
    (TEST_FLAG.programCounter_TestResult == CLASSB_TEST_PASS) &&
    (TEST_FLAG.checkerboardRam_TestResult == CLASSB_TEST_PASS) &&
    (TEST_FLAG.marchCRam_TestResult == CLASSB_TEST_PASS) &&
    (TEST_FLAG.marchCRamStack_TestResult == CLASSB_TEST_PASS) &&
    (TEST_FLAG.marchBRam_TestResult == CLASSB_TEST_PASS) &&
    (TEST_FLAG.flash_TestResult == CLASSB_TEST_PASS))
    {
        TEST_FLAG.returnCode = CLASSB_TEST_PASS;
    }

    return TEST_FLAG.returnCode;
}

/**************************************************************************************/
/**************************************************************************************/
/* Section: Interface Functions                                                       */
/**************************************************************************************/
/**************************************************************************************/

/*!************************************************************************************* 
  Function:
   void TEST_Tasks (void)

  Summary:
   Function to perform self test on PIB controller before system initialization. 

  Remarks:
    Refer to the test.h interface header for function usage details.
 */

void TEST_Tasks (void)
{ 
    (void)ClassB_Test();           
}



/***************************************************************************************
 End of File
 */
